name: Deploy Traffic VM

on:
  push:
    branches: [ main ]
    paths:
      - '.github/workflows/deploy-traffic-vm.yml'
  workflow_dispatch:
    inputs:
      vm_name:
        description: 'Name for the Traffic VM'
        required: false
        default: 'traffic-interceptor'
      machine_type:
        description: 'Machine type for the VM'
        required: false
        default: 'e2-standard-2'

env:
  PROJECT_ID: ${{ secrets.GCP_PROJECT_ID }}
  REGION: us-central1
  ZONE: us-central1-a

jobs:
  deploy-traffic-vm:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout
      uses: actions/checkout@v4

    - name: Google Auth
      id: auth
      uses: 'google-github-actions/auth@v2'
      with:
        credentials_json: '${{ secrets.GCP_SA_KEY }}'

    - name: Create startup script
      run: |
        cat > startup-script.sh << 'EOF'
        #!/bin/bash
        set -e

        # Update system
        apt-get update
        apt-get install -y python3 python3-pip iptables-persistent curl wget

        # Install mitmproxy
        pip3 install mitmproxy

        # Create traffic user
        useradd -m -s /bin/bash traffic
        
        # Create directories for logs and certificates
        mkdir -p /opt/traffic/{logs,certs}
        chown -R traffic:traffic /opt/traffic

        # Generate traffic proxy certificates
        sudo -u traffic mitmproxy --set confdir=/opt/traffic/certs &
        TRAFFIC_PID=$!
        sleep 5
        kill $TRAFFIC_PID || true

        # Install traffic CA certificate to system trust store
        cp /opt/traffic/certs/mitmproxy-ca-cert.pem /usr/local/share/ca-certificates/mitmproxy-ca-cert.crt
        update-ca-certificates

        # Create traffic proxy script
        cat > /opt/traffic/traffic_script.py << 'SCRIPT_EOF'
        import json
        import datetime
        from mitmproxy import http

        def request(flow: http.HTTPFlow) -> None:
            log_entry = {
                "timestamp": datetime.datetime.now().isoformat(),
                "type": "request",
                "method": flow.request.method,
                "url": flow.request.pretty_url,
                "headers": dict(flow.request.headers),
                "content": flow.request.content.decode('utf-8', errors='ignore') if flow.request.content else ""
            }
            
            with open("/opt/traffic/logs/traffic.jsonl", "a") as f:
                f.write(json.dumps(log_entry) + "\n")

        def response(flow: http.HTTPFlow) -> None:
            log_entry = {
                "timestamp": datetime.datetime.now().isoformat(),
                "type": "response",
                "status_code": flow.response.status_code,
                "url": flow.request.pretty_url,
                "headers": dict(flow.response.headers),
                "content": flow.response.content.decode('utf-8', errors='ignore') if flow.response.content else ""
            }
            
            with open("/opt/traffic/logs/traffic.jsonl", "a") as f:
                f.write(json.dumps(log_entry) + "\n")
        SCRIPT_EOF

        chown traffic:traffic /opt/traffic/traffic_script.py

        # Set up iptables rules for traffic interception
        # Redirect HTTP traffic to traffic proxy
        iptables -t nat -A OUTPUT -p tcp --dport 80 -j REDIRECT --to-port 8080
        # Redirect HTTPS traffic to traffic proxy
        iptables -t nat -A OUTPUT -p tcp --dport 443 -j REDIRECT --to-port 8080

        # Save iptables rules
        iptables-save > /etc/iptables/rules.v4

        # Create systemd service for traffic proxy
        cat > /etc/systemd/system/trafficproxy.service << 'SERVICE_EOF'
        [Unit]
        Description=Traffic Proxy for Traffic Interception
        After=network.target

        [Service]
        Type=simple
        User=traffic
        WorkingDirectory=/opt/traffic
        ExecStart=/usr/local/bin/mitmdump -s /opt/traffic/traffic_script.py --set confdir=/opt/traffic/certs --listen-port 8080 --mode transparent
        Restart=always
        RestartSec=3

        [Install]
        WantedBy=multi-user.target
        SERVICE_EOF

        # Enable and start the service
        systemctl daemon-reload
        systemctl enable trafficproxy
        systemctl start trafficproxy

        # Create log rotation for traffic logs
        cat > /etc/logrotate.d/traffic << 'LOGROTATE_EOF'
        /opt/traffic/logs/traffic.jsonl {
            daily
            rotate 7
            compress
            delaycompress
            missingok
            notifempty
            create 644 traffic traffic
        }
        LOGROTATE_EOF

        echo "Traffic VM setup completed successfully"
        EOF

        chmod +x startup-script.sh

    - name: Create or Update Traffic VM
      run: |
        VM_NAME="${{ github.event.inputs.vm_name || 'traffic-interceptor' }}"
        MACHINE_TYPE="${{ github.event.inputs.machine_type || 'e2-standard-2' }}"
        
        # Check if VM exists
        if gcloud compute instances describe $VM_NAME --zone=${{ env.ZONE }} &>/dev/null; then
          echo "VM $VM_NAME already exists. Stopping and updating..."
          gcloud compute instances stop $VM_NAME --zone=${{ env.ZONE }} --quiet || true
          sleep 10
          gcloud compute instances start $VM_NAME --zone=${{ env.ZONE }} --quiet
        else
          echo "Creating new Traffic VM: $VM_NAME"
          gcloud compute instances create $VM_NAME \
            --zone=${{ env.ZONE }} \
            --machine-type=$MACHINE_TYPE \
            --image-family=ubuntu-2204-lts \
            --image-project=ubuntu-os-cloud \
            --boot-disk-size=50GB \
            --boot-disk-type=pd-standard \
            --tags=traffic-vm,http-server,https-server \
            --metadata-from-file startup-script=startup-script.sh \
            --scopes=https://www.googleapis.com/auth/cloud-platform
        fi

    - name: Create firewall rules
      run: |
        # Allow SSH access
        gcloud compute firewall-rules create allow-ssh-traffic \
          --allow tcp:22 \
          --source-ranges 0.0.0.0/0 \
          --target-tags traffic-vm \
          --description "Allow SSH to Traffic VM" || echo "Firewall rule already exists"
        
        # Allow HTTP/HTTPS for testing
        gcloud compute firewall-rules create allow-http-https-traffic \
          --allow tcp:80,tcp:443,tcp:8080 \
          --source-ranges 0.0.0.0/0 \
          --target-tags traffic-vm \
          --description "Allow HTTP/HTTPS to Traffic VM" || echo "Firewall rule already exists"

    - name: Get VM Information
      run: |
        VM_NAME="${{ github.event.inputs.vm_name || 'traffic-interceptor' }}"
        echo "VM Details:"
        gcloud compute instances describe $VM_NAME --zone=${{ env.ZONE }} --format="table(name,status,machineType.basename(),networkInterfaces[0].accessConfigs[0].natIP:label=EXTERNAL_IP)"
        
        echo ""
        echo "Connection Information:"
        EXTERNAL_IP=$(gcloud compute instances describe $VM_NAME --zone=${{ env.ZONE }} --format="get(networkInterfaces[0].accessConfigs[0].natIP)")
        echo "SSH: ssh -i ~/.ssh/gcp_key $USER@$EXTERNAL_IP"
        echo "Traffic logs: /opt/traffic/logs/traffic.jsonl"
        echo "Traffic CA cert: /opt/traffic/certs/mitmproxy-ca-cert.pem"
        echo ""
        echo "To view traffic logs in real-time:"
        echo "tail -f /opt/traffic/logs/traffic.jsonl | jq ."

    - name: Cleanup
      run: rm -f startup-script.sh